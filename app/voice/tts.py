"""
Text-to-Speech (TTS) Module.

Converts text responses generated by the Phase 1 honeypot into spoken
audio using Google Text-to-Speech (gTTS).  Supports English and several
Indic languages commonly encountered in scam interactions.

This module is part of Phase 2 voice features and sits on the output
side of the pipeline: Phase 1 produces text, TTS converts it to an
audio file that can be streamed back to the caller.
"""

import os
import tempfile
from pathlib import Path
from typing import Dict, Optional

from gtts import gTTS

from app.config import settings
from app.utils.logger import get_logger

logger = get_logger(__name__)

# ---------------------------------------------------------------------------
# Language mapping
# ---------------------------------------------------------------------------
# Maps human-readable language names to ISO 639-1 codes accepted by gTTS.
# All keys are stored in lowercase for case-insensitive lookup.

LANGUAGE_MAP: Dict[str, str] = {
    "english": "en",
    "hindi": "hi",
    "gujarati": "gu",
    "tamil": "ta",
    "telugu": "te",
    "bengali": "bn",
    "marathi": "mr",
}

SUPPORTED_LANGUAGE_CODES: set = set(LANGUAGE_MAP.values())

SUPPORTED_TTS_ENGINES = ("gtts",)


class TTSEngine:
    """Text-to-Speech engine powered by Google TTS (gTTS).

    Converts plain text into MP3 audio files with support for multiple
    languages.  Designed to sit downstream of the Phase 1 honeypot text
    pipeline.

    Attributes:
        engine: Name of the active TTS backend (currently only 'gtts').
    """

    def __init__(self) -> None:
        """Initialize the TTS engine.

        Reads the ``TTS_ENGINE`` setting to determine which backend to
        use.  Currently only ``"gtts"`` is supported; any other value
        causes a ``ValueError``.

        Raises:
            ValueError: If the configured TTS engine is not supported.
        """
        self.engine: str = getattr(settings, "TTS_ENGINE", "gtts")

        if self.engine not in SUPPORTED_TTS_ENGINES:
            raise ValueError(
                f"Unsupported TTS engine '{self.engine}'. "
                f"Must be one of: {', '.join(SUPPORTED_TTS_ENGINES)}"
            )

        logger.info("TTSEngine initialized with engine=%s", self.engine)

    def synthesize(
        self,
        text: str,
        language: str = "en",
        output_path: Optional[str] = None,
    ) -> str:
        """Convert text to an audio file.

        Args:
            text: The text content to synthesize.  Must be non-empty.
            language: Language for speech synthesis.  Accepts either an
                ISO 639-1 code (``'hi'``) or a full language name
                (``'hindi'``).  Defaults to English (``'en'``).
            output_path: Destination file path for the generated MP3.
                When ``None``, a temporary file is created automatically.

        Returns:
            Absolute path to the generated ``.mp3`` file.

        Raises:
            ValueError: If *text* is empty or *language* is not supported.
            RuntimeError: If audio synthesis or file writing fails.
        """
        self._validate_text(text)
        resolved_lang: str = self._resolve_language(language)
        target_path: str = self._resolve_output_path(output_path)

        try:
            logger.info(
                "Synthesizing speech: language=%s, text_length=%d, "
                "output=%s",
                resolved_lang,
                len(text),
                target_path,
            )

            tts = gTTS(text=text, lang=resolved_lang)
            tts.save(target_path)

            file_size: int = os.path.getsize(target_path)
            logger.info(
                "Speech synthesis complete: output=%s, size=%d bytes",
                target_path,
                file_size,
            )

            return target_path

        except ValueError:
            # Re-raise validation errors from gTTS (e.g. empty text after
            # internal stripping) without wrapping.
            raise
        except Exception as exc:
            logger.error("TTS synthesis failed: %s", exc)
            # Clean up partial file on failure
            self._cleanup_file(target_path)
            raise RuntimeError(
                f"TTS synthesis failed for language '{resolved_lang}': {exc}"
            ) from exc

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _validate_text(text: str) -> None:
        """Validate that the input text is suitable for synthesis.

        Args:
            text: Raw input text.

        Raises:
            ValueError: If *text* is empty or whitespace-only.
        """
        if not text or not text.strip():
            raise ValueError(
                "Cannot synthesize empty text. Provide non-empty input."
            )

    @staticmethod
    def _resolve_language(language: str) -> str:
        """Normalize a language identifier to an ISO 639-1 code.

        Accepts either a full name (``'hindi'``) or an ISO code
        (``'hi'``).  Lookup is case-insensitive.

        Args:
            language: Language name or ISO 639-1 code.

        Returns:
            Two-letter ISO 639-1 language code.

        Raises:
            ValueError: If the language is not in the supported set.
        """
        normalized: str = language.strip().lower()

        # Direct ISO code match
        if normalized in SUPPORTED_LANGUAGE_CODES:
            return normalized

        # Full-name lookup
        code: Optional[str] = LANGUAGE_MAP.get(normalized)
        if code is not None:
            return code

        supported_display = ", ".join(
            f"{name} ({code})"
            for name, code in sorted(LANGUAGE_MAP.items())
        )
        raise ValueError(
            f"Unsupported language '{language}'. "
            f"Supported languages: {supported_display}"
        )

    @staticmethod
    def _resolve_output_path(output_path: Optional[str]) -> str:
        """Determine the output file path for the synthesized audio.

        When *output_path* is ``None``, a temporary file with a
        ``.mp3`` suffix is created.  When provided, parent directories
        are created as needed.

        Args:
            output_path: Explicit file path, or ``None`` for auto.

        Returns:
            Absolute path to the target MP3 file.
        """
        if output_path is None:
            fd, path = tempfile.mkstemp(suffix=".mp3", prefix="tts_")
            os.close(fd)
            return path

        target = Path(output_path)
        target.parent.mkdir(parents=True, exist_ok=True)
        return str(target.resolve())

    @staticmethod
    def _cleanup_file(path: str) -> None:
        """Remove a file if it exists, suppressing errors.

        Used to clean up partial output files after a synthesis failure.

        Args:
            path: File path to remove.
        """
        try:
            if os.path.exists(path):
                os.remove(path)
        except OSError:
            pass

    def get_supported_languages(self) -> Dict[str, str]:
        """Return the full language mapping.

        Returns:
            Dictionary mapping language names to ISO 639-1 codes.
        """
        return dict(LANGUAGE_MAP)


# ---------------------------------------------------------------------------
# Module-level singleton
# ---------------------------------------------------------------------------

_tts_engine: Optional[TTSEngine] = None


def get_tts_engine() -> TTSEngine:
    """Get or create the global TTS engine instance.

    Uses the singleton pattern so that engine initialization (including
    configuration validation) happens only once.

    Returns:
        The shared TTSEngine instance.
    """
    global _tts_engine

    if _tts_engine is None:
        logger.info("Creating TTS engine singleton")
        _tts_engine = TTSEngine()

    return _tts_engine
